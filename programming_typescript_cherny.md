- # Chapter 1: Introduction
    - [[type safety]]: using types to prevent programs from doing invalid things.

- # Chapter 2: TypeScript: A 10_000 Foot View
    - When you run a program, what you're really doing is telling the runtime to evaluate the [[bytecode]] generated by the compiler from the [[abstract syntax tree]] ([[AST]]) parsed from your source code.
    - Instead of compiling straight to [[bytecode]], [[TypeScript]] compiles to [[JavaScript]] code.
    - After the [[TypeScript]] compiler generates the [[AST]] for your program – but before it emits the code – it typechecks your code.
    - [[typechecker]]: a special program that verifies that your code is typesafe.
    - [[JavaScript]] compilers and runtimes tend to be smushed into a single program called an [[engine]].
        - Gives the appearance of JS being an interpreted language.
    - When TSC compiles from [[TypeScript]] to [[JavaScript]], it doesn't look at types.
        - Types never affect generated output – they're only for type checking.
        - Can't break application playing around with types.

    - ## The Type System
        - [[type system]]: a set of rules that a [[typechecker]] uses to assign types to your program.
        - You can explicitly annotate your types, or let [[TypeScript]] infer most of them.
            - ```javascript
let a: number = 1;
let b: string = "hello";
let c: boolean{} = [true, false];

let a = 1;
let b = "hello";
let c = [true, false];```
            - Good practice to let [[TypeScript]] infer as many types as it can.

        - ### TypeScript Versus JavaScript
            - **How are types bound?** JS: Dynamically; TS: Statically
                - [[TypeScript]] is [[gradually typed]]. It works best when it knows all types at compile time, but doesn't have to.
                    - Useful for migrating legacy codebases.
            - **Are types automatically converted?** JS: Yes; TS: No (mostly)
                - If you must convert types, do it explicitly.
            - **When are types checked? **JS: At runtime; TS: At compile time
            - **When are errors surfaced?** JS: At runtime (mostly); TS: At compile time (mostly)
                - Errors [[TypeScript]] can't catch at compile time include stack overflows, broken network connections and malformed user inputs.
                - [[TypeScript]] make compile-time errors out of most errors that would be runtime errors in [[JavaScript]].
                - [[incrementally compiled]] languages can be quickly recompiled on small changes, rather than recompiling the whole program.
    - ## Code Editor Setup
        - [[TSC]] is a [[self-hosting compiler]] – a compiler that compiles itself.
        - ```javascript
npm install --save-dev typescript tslint @types/node```
        - `tsconfig.json` in the root directory is where [[TypeScript]] defines which files should be compiled, where to compile them to and which version of [[JavaScript]] to emit.
            - ```javascript
{
  "compilerOptions": {
    "lib": ["es2015"],
    "module": "commonjs",
    "outDir": "dist",
    "sourceMap": true,
    "strict": true,
    "target": "es2015"
  },
  "include": [
    "src"
  ]
}```
            - `include`: where TS files are located.
            - `lib`: the APIs [[TSC]] should assume exist in the environment the code will run in.
            - `module`: the module system [[TSC]] should compile to ([[CommonJS]], [[SystemJS]], ES2015, etc.).
            - `outDir`: where to put generated [[JavaScript]] code.
            - `sourceMap`: preserves reference to original typing for debugging.
            - `strict`: enforces that all code is properly typed.
            - `target`: the [[JavaScript]] version to compile your code to.
            - Use [[TSC]]'s initialize command to generate `tsconfig.json` automatically: `./node_modules/.bin/tsc --init`.
            - Also set [[TSC]] options from the command line: `./node_modules/.bin/tsc --help`.
        - `tslint.json` contains stylistic conventions to enforce. Optional but recommended.
            - Generate automatically with `./node_modules/.bin/tslint --init`.
        - Compile [[TypeScript]]: `./node_modules/.bin/tsc`
        - Run compiled [[JavaScript]]: `node ./dist/index.js`
        - The `ts-node` package compiles and runs [[TypeScript]] in a single command.
        - Use a scaffolding tool like `typescript-node-starter` to quickly generate a folder structure.
- # Chapter 3: All About Types
    - [[type]]: a set of values and the things you can do with them.
    - ## Talking About Types
        - ```javascript
function squareOf(n: number) {
  return n * n;
}

squareOf(2);```
            - `squareOf`'s parameter is **constrained to** `number`.
            - The type of the value 2 is **assignable to** `number`.
            - In terms of **bounds:** `n`'s **upper bound** is `number`, so any value passed to `squareOf` must be at most a `number`.
    - ## The ABCs of Types
        - ### `[[any]]`
            - Everything needs to have a type at compile time, any `any` is the default type when you and [[TypeScript]] cant figure out what type something is.
            - Avoid where possible.
        - ### `[[unknown]]`
            - For values whose type you don't know ahead of time.
            - [[TypeScript]] won't let you use an `unknown` type until you **refine** it by checking what it is.
                - When unknown is part of a union type, the result of the union will be `unknown`.
            - [[TypeScript]] will never infer something as `unknown` – must be annotated.
            - `unknown` values are comparable.
        - ### `[[boolean]]`
            - ```javascript
const c = true;
let e: true = true;```
                - By using a value as a type, you limit the possible values from all booleans to one specific boolean each.
                - [[type literal]]: a type that represents a single value and nothing else.
                - [[TypeScript]] knows that once a primitive is assigned with `const` its value will never change, so it infers the narrowest type it can for that variable.
        - ### `[[number]]`
            - You can't use `NaN`, `Infinity` or `-Infinity` as type literals.
        - ### `[[symbol]]`
            - In [[Javascript]], `Symbol('a')` works by creating a new `symbol` with the given name.
                - That symbol is unique and won't be equal to any other symbol, even if the second symbol has the same name.
            - Symbols are inferred to be of type `symbol` but can be explicitly typed as `[[unique symbol]]`.
            - When a new symbol is assigned to a `const`, [[TypeScript]] will infer its type as `unique symbol`.
            - In code editors, unique symbols show up as `typeof variableName` rather than `unique symbol`.
            - A `unique symbol` is always equal to itself.
            - [[TypeScript]] always knows at compile time that a `unique symbol` will never be equal to any other `unique symbol`.
        - ### `[[object]]`
            - JavaScript is generally **structually types**, so TypeScript favours that style of programming over [[nominal typing]].
            - [[structural typing]]: a style of programming where you just care that an object has certain properties, and not what its name is ([[nominal typing]]). Also called [[duck typing]] in some languages.
            - ```javascript
let a = {
  b: 'x'
};			// { b: string }

let b = {
  c: {
    d: 'f'	
  }
};			// { c: { d: string }}

let a: { b: number } = {
  	b: 12
};			// { b: number }```
                - You can let [[TypeScript]] infer your object's shape for you, or explicitly describe it inside curly braces.
            - [[type inference]] **When Declaring Objects with** `**const**`
                - ```javascript
const a: { b: number } = {
	b: 12         
}		// Still { b: number }```
                - Unlike other primitive types, declaring an object with `const` won't cause [[TypeScript]] to infer its type more narrowly, because objects are mutable.
            - [[definite assignment]]: when you declare a variable, [[TypeScript]] will make sure it is definitely assigned a value by the time you use it.
            - ```javascript
let a: {
  b: number
  c?: string // 1
  [key: number]: boolean //2
}```
                - 1. `a` might has optional property `c` that's a string.
                    - If `c` is set, it might be `undefined`.
                - 2. `a` might have any number of numeric properties that are booleans.
            - [[index signatures]]: `[key: T]: U`
                - All keys of type `T` must have values of type `U`.
                - Index signatures let you safely add more keys to an object in addition to those explicitly declared.
                - `T` must be assignable to either `number` or `string`.
                - You can use any word for the key name, not just `key`.
            - You can mark object fields as `readonly`, similar to `const` but for object properties:
                - ```javascript
let user: {
  readonly firstName: string
} = {
  firstName: "abby"
}```
            - The empty object type (`{}`) is a special case: every type except `null` and `undefined` is assignable to an empty object type.
                - Avoid empty object types where possible.
            - Similar to the empty object type is `Object`. Also best avoided.
                - `{}` lets you define what you want for built-in methods on the `Object` prototype, like `.toString` and `.hasOwnProperty`.
                - `Object` enforces the types you declare are assignable to those on `Object`'s prototype.
            - Four ways to declare objects in [[TypeScript]] :
                - Object literal notation (`{a : string}`), also called a **shape**. Use when you know which fields your object could have, or when all values will have the same type.
                - Empty object literal notation (`{}`). Avoid this.
                - The `object` type. Use when you just want an object and don't care what fields it has.
                - The `Object` type. Try to avoid this.
        - ### [[type alias]], [[union]] and [[intersection]]
            - You can declare a [[type alias]] that points to a type:
                - ```javascript
type Age = number

type Person = {
  name: string,
  age: Age
}```
                - Aliases a never inferred by [[TypeScript]], so you have to type them explicitly.
                - Because `Age` is just an alias for `number`, it's also assignable to `number`.
            - Whenever you see a [[type alias]] used, you can substitute the type it aliases without changing the meaning of your program.
            - [[type alias]]es are block-scoped. Inner type alias declarations are shadow outer ones.
            - [[type alias]]es are useful for DRYing up repeated complex types, and for making it clear what a variable is used for.
            - When deciding whether or not to alias a type, use the same judgment as when deciding whether or not to pull a value out into its own variable.
            - **Union and Intersection Types**
                - [[union type]]: every property in all the types in the union, defined with `|`.
                    - A value with a [[union type]] isn't necessarily one specific member of your union; it can be both members at once.
                - [[intersection type]]: the properties they have in common, defined with `&`.
        - ### [[array]]
            - Two syntaxes for arrays: `T[]` and `Array<T>`.
                - Identical in meaning an performance.
            - General rule of thumb: keep arrays homogeneous.
                - If you don't, you have to check the type of each item before you use it.
            - Creating arrays with `const` won't hint to infer their type more narrowly because they're mutable.
            - When you initialize an empty array, [[TypeScript]] doesn't know what type the array's elements should be and makes them `any`.
                - Once the array leaves the scope it was defined in (e.g. returned from a function), [[TypeScript]] assigns it a final type.
        - ### [[tuple]]
            - Subtype of array.
            - Used to declare arrays of fixed lengths where the values at each index have specific, known types.
            - Must be explicitly typed when declared.
            - `let b: [string, string, number] = ['malcolm', 'gladwell', 1963]`
            - Tuples support optional elements:
                - ```javascript
let trainFares: [number, number?][] = [
  [3.75],
  [8.25, 7.70],
  [10.50]
]```
            - Tuples support rest elements to type tuples with minimum lengths:
                - `let friends: [string, ...string[]] = ['Sara', 'Tali', 'Chloe']`
            - **Read-only arrays and tuples**
                - [[read-only array]]s can't be updated in place.
                - `let arr: readonly number[] = [1, 2, 3]`
                - There are also functionally identical long-form declarations:
                    - ```javascript
type A = readonly string[]
type B = ReadonlyArray<string>
type C = Readonly<string[]>
type D = readonly [number, string]
type E = Readonly<[number, string]>```
                - [[read-only array]]s are backed by regular [[JavaScript]] arrays.
                    - Even small updates can result in having to copy the original array first. For large arrays, the overhead is significant.
                    - Consider a more efficient implementation, like Lee Byron's `immutable`.
        - ### [[null]], [[undefined]], [[void]] and [[never]]
            - In [[JavaScript]], the only thing of type `undefined` is the value `undefined`, and the only thing of type `null` is the value `null`.
            - `[[undefined]]`: something hasn't been defined yet.
            - `[[null]]`: the absence of a value.
            - `[[void]]`: the return type of a function that has no explicit return value.
            - `[[never]]`: is the type of a function that never returns (e.g. infinite loops or always throws exception).
                - If `[[unknown]]` is the supertype of all other types, then `[[never]]` is the subtype of every other type.
                - Known as a [[bottom type]].
                    - A [[bottom type]] is a type that has no values. It corresponds to a mathematical proposition that is always false.
                - Assignable to every other type.
                - A value of never can be used anywhere safely.
        - ### [[enum]]s
            - Enums enumerate all possible values for a type.
            - Unordered data structures that map keys to values.
            - Like objects where keys are fixed at compile time, so [[TypeScript]] can check that the given key actually exists when you access it.
            - Two kinds: maps from strings to strings, and maps from strings to numbers.
            - ```javascript
enum Language {
  English,
  Spanish,
  Russian
}```
            - [[TypeScript]] automatically infers a number as the value for each member, but you can also set them explicitly:
                - ```javascript
enum Language {
  English = 0,
  Spanish = 1,
  Russian = 2
}```
            - Retrieve values with dot or bracket notation like a regular object.
            - You can split your [[enum]]across multiple declarations, and [[TypeScript]] will automatically merge them.
                - ```javascript
enum Language {
  English = 0,
  Spanish = 1
}

enum Language {
  Russian = 2
}```
            - Computed values:
                - ```javascript
enum Language {
  English = 100,
  Spanish = 200 + 300,
  Russian	// Inferred to be 501
}```
            - String values:
                - ```javascript
enum Color {
  Red = "#c10000",
  Blue = "#007ac1"
}```
            - You can access [[enum]]s by value, but this can be unsafe. E.g. `let d = Color[6]` doesn't exist, but [[TypeScript]] won't stop you.
            - `const [[enum]]`s prevent this kind of unsafe access as they are only accessible using string literal keys.
                - By default, `const [[enum]]`s are inlined and don't generate any [[JavaScript]] code.
                - Inlining can lead to safety issues when you import a `const [[enum]]` from someone else's code: if the author updates their `const enum` after you've compiled your code, then your version of the enum and their version might point to different values at runtime
                - Avoid using `const [[enum]]`s in programs you're planning to publish.
                - To enable runtime code generation for `const [[enum]]`s, set `preserveConstEnums: true` in `tsconfig.json`.
                - All numbers are also assignable to [[enum]]s, so the number 12 is a valid member of an `enum` than contains 5 entries.
                    - To avoid this, you have to ensure you use only string-valued enums:
                        - ```javascript
const enum Flippable {
  Burger = "burger",
  Chair = "Chair",
  Cup = "Cup"
}

function flip(f: flippable) {
  return "flipped it"
}

flip(12) // Error```
            - Because of all the pitfalls that come with using [[enum]]s safely, stay away from them.
- # Chapter 4: Functions
    - ## Declaring and Invoking Functions
        - [[JavaScript]] and [[TypeScript]] support at least 5 ways of declaring functions:
            - ```javascript
// Named function
function greet(name: string) {
  return "hello" + name
}

// Function expression
let greet2 = function(name: string) {
  return "hello" + name
}

// Arrow function expression
let greet3 = (name: string) => {
  return "hello" + name
}

// Shorthand arrow function expression
let greet4 = (name: string) => 
	return "hello" + name

// Function constructor
let greet5 = new Function("name", "return 'hello ' + name")
```
            - [[function constructors]] are unsafe. The parameters and return type of the Function type created are untyped, so you can call the function with any arguments you want.
    - ## Optional and Default Parameters
        - Use `?` to mark optional parameters.
        - Required parameters must come first, followed by optional parameters.
            - ```javascript
function log(message: string, userId?: string) {
  ...
}```
        - Default parameters don't have to come at the end of the list:
            - ```javascript
function log(message: string, userId = "Not signed in") {
  ...
}```
            - Note that, with a default value, `userId` no longer has to be optional.
    - ## [[rest parameter]]s
        - [[JavaScript]]'s `arguments` object holds an array-like list of arguments passed to the function:
            - ```javascript
function sumVariadic(): number {
  return Array
  	.from(arguments)
  	.reduce((total, n) => total + n, 0)
}```
            - This is unsafe: both `n` and `total` have the `[[any]]` type.
        - [[rest parameter]]s are used to safely accept a variable number of arguments:
            - ```javascript
function sumVariadic(...numbers: number[]): number {
  return numbers.reduce((total, n) => total + n, 0)
}```
            - A function can have at most one rest parameter, which must come at the end of the parameter list.
    - ## `[[call]]`, `[[apply]]` and `[[bind]]`
        - ```clojure
add(10, 20)
add.apply(null, [10, 20])
add.call(null, 10, 20)
add.bind(null, 10, 20)()```
        - `[[apply]]` binds a value to `[[this]]` within the function (`null` in this case) and spreads its second argument over the functions's parameters.
        - `[[call]]` applies its arguments in order instead of spreading.
        - `[[bind]]` binds a `[[this]]`-argument and returns a new function that you can later invoke with `()`, `.call` or `.apply`, passing more arguments in to be bound to the so far unbound parameters if you want.
    - ## Typing `[[this]]`
        - `[[this]]` has a different value depending on how you called your function, which can make it notoriously fragile and hard to reason about.
        - Lots of teams ban `this` everywhere except in class methods. Enable that `invalid-this` TSLint rule to do so.
        - Generally, `[[this]]` will take the value of the thing to the left of the dot when invoking a method.
            - ```javascript
let x = {
  a() {
    return this
  }
}

x.a() // returns x```
            - I.e. the execution context, not the declaration context.
            - Arrow functions preserve their declaration context.
        - If reassign `a` before calling it, the context will change:
            - ```javascript
let a = x.a
a() // returns undefined. this is not bound```
        - If your function uses `[[this]]`, declare your expected `this` type as your function's first parameter. [[TypeScript]] will enforce that `this` is what you expect at every call site.
            - `[[this]]` isn't treated like other parameters – it's a reserved word when used as part of a function signature.
    - ## Generator Functions
        - [[generator]]s give the consumer fine control over the pace at which values are produced.
        - [[generator]]s are lazy: they only compute the next value when a consumer asks for it.
        - ```javascript
function* createFibonacciGenerator() {
  let a = 0
  let b = 1
  while (true) {
    yield a;
    [a, b] = [b, a + b]
  }
}```
            - An asterisk before a function's name makes it a [[generator]].
            - Calling a [[generator]] returns an `[[IterableIterator]]`.
            - When a consumer asks for the generator's next value (e.g. by calling `next`), `[[yield]]` sends a result and pauses execution until the consumer asks for the next value.
            - [[TypeScript]] infers the type of the `[[IterableIterator]]` from the type of the value yielded. E.g. `IterableIterator<number>`.
        - [[iterable]]: any object that contains a property called `Symbol.iterator`, whose value is a function that returns an [[iterator]].
        - [[iterator]]: any object that defines a method called `next`, which returns an object with the properties `value` and `done`.
        - Manually define an [[iterable]] or an [[iterator]] by creating and object or class that implements `Symbol.iterator` or `next` respectively.
            - ```javascript
let numbers = {
  *[Symbol.iterator]() {
    for (let n = 1; n <= 10; n++) {
      yield n
    }
  }
}```
                - `numbers` is an [[iterable]], and calling `numbers[Symbol.iterator]()` returns an `[[IterableIterator]]`.
        - You can use [[JavaScript]]'s built-in [[iterator]]s for common collection types to do things like:
            - ```javascript
// Iterate over an iterator with for-of
for (let a of numbers) {
  // 1, 2, 3, etc.
}

// Spread an iterator
let allNumbers = [...numbers] // number[]

// Destructure an iterator
let [one, two, ...rest] = numbers // [number, number, number[]]```
            - `Object` and `number` are not iterators.
    - ## [[call signature]]s
        - Expressed like `(a: number, b: number) => number`
        - Function [[call signature]]s contain only type-level code – types only, no values.
            - Cannot express [[default value]]s.
        - Type-level code consists only of types and type operators.
        - Value-level code is everything else.
        - To declare a function that implements a signature:
            - ```javascript
type Log = (message: string, userId?: string) => void

let log: Log = (
  message,
  userId = "Not signed in"
) => {
  // ...
}```
    - ## [[contextual typing]]
        - Because we declared `log` to be of type `Log` (above) [[TypeScript]] infers that `message` must be of type string. This is an example of [[contextual typing]].
        - ```javascript
function times(
  f: (index: number) => void,
  n: number
) {
  // ...
}

times(n => console.log(n), 4)```
            - If `f` wasn't declared inline, [[TypeScript]] wouldn't be able to infer its type.
    - ## Overloaded Function Types ([[overloading]])
        - `type Fn = (...) => ...` is a shorthand [[call signature]].
        - A full [[call signature]]:
            - ```javascript
type Log = {
  (message: string, userId?: string): void
}```
        - [[overloading]] a function: creating a function with multiple [[call signature]]s.
        - A travel booking API might support both return and one-way trips:
            - ```javascript
type Reserve = {
  (from: Date, to: Date, destination: String): Reservation
  (from: Date, destination: String): Reservation
}```
            - When such a function is implemented, it must have a single, combined type:
                - ```javascript
let reserve: Reserve = (
  from: Date,
  toOrDestination: Date | string,
  destination?: string
) => {
  // ...
}```
            - The combined signature isn't visible to functions that call reserve. From a consumer's point of view, `Reserve`'s signature is:
                - ```javascript
type Reserve = {
  (from: Date, to: Date, destination: String): Reservation
  (from: Date, destination: String): Reservation
}```
            - Since `reserve` might be called in either of two ways, you have to check how it was called in the implementation:
                - ```javascript
let reserve: Reserve = (
  from: Date,
  toOrDestination: Date | String,
  destination?: string
) => {
  if (toOrDestination instanceof Date && destination !== undefined) {
    // Book a return trip
  } else if (typeof toOrDestination === 'string') {
    // Book a one-way trip
  }
}```
        - Overloads come up naturally in browser [[DOM]] APIs. [[TypeScript]] comes with built-on types for each HTML element, allowing function [[overloading]] like:
            - ```javascript
type CreateElement = {
  (tag: "a"): HTMLAnchorElement
  (tag: "canvas"): HTMLCanvasElement
  (tag: "table"): HTMLTableElement
  (tag: "string"): HTMLElement
}

let createElement: CreateElement = (tag: string): HTMLElement => {
  // ...
}```
            - [[TypeScript]] resolves overloads in the order they were declared, so when you call `createElement` with a string that doesn't have a specific overload defined, it falls back to `HTMLElement`.
                - [[hoisting]]: [[TypeScript]] hoists literal overloads above non-literal ones, before resolving them in order. Don't depend on this, since it can make overloads hard to understand.
            - Since all string literal types are subtypes of `string`, the type reduces to just `string` in the implementation's parameter.
        - To overload function declarations, not just function expressions:
            - ```javascript
function createElement(tag: "a"): HTMLAnchorElement
function createElement(tag: "canvas"): HTMLCanvasElement
function createElement(tag: "table"): HTMLTableElement
function createElement(tag: "string"): HTMLElement {
  // ...
}```
        - You can use full type signatures to assign properties to [[JavaScript]] functions, which are just callable objects:
        - ```javascript
type WarnUser = {
  (warning: string): void,
  wasCalled: boolean
}

function warnUser(warning) {
  if (warnUser.wasCalled) {
    return
  }
  warnUser.wasCalled = true
  alert(warning)
}
warnUser.wasCalled = false```
    - ## [[polymorphism]]
        - [[generic]] type parameter: a placeholder type used to enforce a type-level constraint in multiple places.
            - Also known as a polymorphic type parameter.
        - ```javascript
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[]
}```
        - You can declare as many comma-separated [[generic]] type parameters as you want between a pair of angle brackets.
        - [[generic]] types can also be used in [[type alias]]es, classes and [[interface]]s.
        - ### When Are [[generic]]s Bound?
            - ```javascript
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[]
}

let filter: Filter = (array, f) =>
  // ...```
                - Because we declared `<T>` as part of a call signature, [[TypeScript]] will bind a concrete type to `T` when we actually **call** a function of type `Filter`.
            - ```javascript
type Filter<T> = {
  (array: T[], f: (item: T) => boolean): T[]
}

type StringFilter = Filter<String>
let stringFilter: StringFilter = (array, f) =>
  // ...```
                - Because `<T>` is scoped to the type alias `Filter`, [[TypeScript]] requires us to bind a type explicitly when `Filter` is used.
            - Generally, [[TypeScript]] will bind concrete types to your [[generic]] when you use it: for functions, it's when you call them; for classes, it's when you instantiate them; and for type aliases and interfaces, it's when you use or implement them.
        - ### Where Can You Declare Generics?
            - ```javascript
// 1
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[]
}
let filter: Filter = // ...

// 2
type Filter<T> = {
  (array: T[], f: (item: T) => boolean): T[]
}
let filter: Filter<number> = // ...
  
//3
function filter<T>(array: T[], f: (item: T) => boolean): T[] {
  // ...
}```
                1. A full [[call signature]], with `T` scoped to an individual signature.
                    - [[TypeScript]] will bind the `T` in this signature to a concrete type when you call a function of type `Filter`.
                    - Each call to `filter` will get its own binding for `T`.
                2. A full [[call signature]], with `T` scoped to all of the signatures.
                    - Because `T` is declared as part of `Filter`'s type (and not part of a specific signature's type), [[TypeScript]] will bind `T` when you declare a function of type `Filter`.
                3. A named function [[call signature]], with `T` scoped to the signature.
                    - [[TypeScript]] will bind a concrete type to `T` when you call `filter`.
                    - Each call to `filter` will get its own binding for `T`.
            - `filter` **and** `map` **in the standard library**
                - ```javascript
interface Array<T> {
  filter(
  	callbackfn: (value: T, index: number, array: T[]) => any,
  	thisArg?: any
  ): T[]
  map<U>(
  	callbackfn: (value: T, index: number, array: T[]) => U,
    thisArg?: any
  ): U[]
}```
                - `filter` uses the [[generic]] `T` that's scoped to the entire `Array` interface.
                - `map` uses `T` too, and adds a second generic `U` that's scoped just to the `map` function.
                - [[TypeScript]] will bind a concrete type to `T` when you create an array, and every call to `filter` and `map` on that array will share that concrete type.
                - Every time you call `map`, it will get its own binding for U.
            - In most cases [[TypeScript]] infers [[generic]] types.
            - You can explicitly annotate generics, but every required [[generic]] type must be annotated if you do:
                - ```javascript
function map<T, U>(array: T[], f: (item: T) => U): U[] {
  // ...
}
map<string, boolean>(
  ["a", "b", "c"],
  _ => _ === "a"
)```
                - [[TypeScript]] will check that each inferred generic type is assignable to its corresponding explicitly bound generic. If it's not, you'll get an error.
            - Sometimes [[TypeScript]] can't infer concrete types and requires annotations:
                - ```javascript
let promise = new Promise(resolve =>
  resolve(45)
)
promise.then(result => // Inferred as {}
  result * 4
)

// Should be...
let promise = new Promise<number>(resolve =>
  resolve(45)
)```
        - ### Generic [[type alias]]es
            - ```javascript
type MyEvent<T> = {
  target: T,
  type: string
}```
            - When you use a [[generic]] type like `MyEvent`, you have to explicitly bind its typer parameters when you use the type; they won't be inferred:
                - ```javascript
let myEvent: MyEvent<HTMLButtonElement | null> = {
  target: document.querySelector("#myButton"),
  type: "click"
}```
            - You can use `MyEvent` to build another type. When the [[generic]] `T` in `TimedEvent` is bound, [[TypeScript]] will also bind it to `MyEvent`:
                - ```javascript
type TimedEvent<T> = {
  event: MyEvent<T>
  from: Date
  to: Date
}```
            - You can use a [[generic]] [[type alias]] in a function signature too. When [[TypeScript]] binds a type to `T`, it'll also bind it to `MyEvent`:
                - ```javascript
function triggerEvent<T>(event: MyEvent<T>): void {
  // ...
}```
        - ### Bounded [[polymorphism]]
            - Saying "the type `U` should be __at least__ `T`", is called putting an **upper bound** on `U`.
                - ```javascript
function mapNode<T extends TreeNode>(
  node: T,
  f: (value: string) => string
): T {
  return {
    ...node,
    value: f(node.value)
  }
}```
                    - If `T` didn't extend `TreeNode`, `mapNode` would have throw a compile-time error, because you can't safely read `node.value` on an unbounded node of type `T`.
            - Bounded [[polymorphism]] with multiple constraints:
                - ```javascript
type HasSides = { numberOfSides: number }
type SidesHaveLength = { sideLength: number }

function logPerimeter<
  Shape extends HasSides & SidesHaveLength
>(s: Shape): Shape {
  // ..
}

type Square = HasSides & SidesHaveLength
let square: Square = { numberOfSides: 4, sideLength: 3 }
logPerimeter(square)```
            - Using bounded [[polymorphism]] to model arity:
                - ```javascript
function call<T extends unknown[], R>(
  f: (...args: T) => R,
  ...args: T
): R {
  return f(...args)
}```
        - ### [[generic]] Type Defaults
            - ```javascript
type MyEvent<T extends HTMLElement = HTMLElement> = {
  target: T
  type: string
}```
            - Like optional parameters, generic types with defaults have to appear after the generic types without defaults:
                - ```clojure
type MyEvent2<
  Type extends string,
  Target extends HTMLElement = HTMLElement,
> = {
  target: Target
  type: Type
}```
    - ## Type-Driven Development
        - Start by defining your functions' type signatures, filling in the implementations later.
